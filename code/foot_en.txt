// --------------------------------------------// Outline: Setup// --------------------------------------------void setup() {    randomSeed(analogRead(0));    resetTimer();    artecRobotSetup();    artecRobotMain();}void loop() {}// --------------------------------------------// Outline    : Delete from the list// Argument   : struct _cell_t *p  List pointer//            : int pos            The position you want to delete from the list// Return     : Success:0, Error:-1// --------------------------------------------int listDelete(struct cell_t* p, int pos){  // When delete position is below 0 return error (no action)  if (pos <= 0) { return (-1); }  // When delete positon is longer than the list return error (no action)  int l = listLength(p);        // Get list length  if (l < pos) { return (-1); }   cell_t *target, *before;      // Element about to be deleted and the one before it  target = p->next;             // Set first element and the one after it  before = NULL;  if (target == NULL) return (-1);  // When there is no target element to delete, return error.  // Move to the target element to be deleted  before = p;  for (int i = 0;i < pos-1;i++) {    if (target->next == NULL) return (-1);  // When there is no target element to be deleted, return error.    before = target;        // Save the one before the target element to be deleted    target = target->next;  // Renew the target element to be deleted  }  // If there is deleted element...  before->next = target->next;  // Set following element to the element one before the target.  delete target;  // Delete the target  return(0);}// --------------------------------------------// Outline    : Adding to the list// Argument   : struct _cell_t *p  List pointer//            : int    data        Additonal data// Return     : Success:0, Error:-1// --------------------------------------------int listAdd(struct cell_t* p, float data){  cell_t *elm, *last;  // Get list elements  elm = new cell_t;  // When failed to get the list elements  if(elm == NULL) {    // Return error    return(-1);  }  // Set the list end at last  last = p;  for (;;) {    if (last->next == NULL) break;    last = last->next;  }  // Set additional elements at the end of the list   elm->data = data;  elm->next = NULL;  last->next = elm;  return(0);}// --------------------------------------------// Outline    : Get list length// Argument   : struct _cell_t *p  List pointer// Return     : List length// --------------------------------------------int listLength(struct cell_t* p){  struct cell_t *last;  // Move to the list end  last = p;  int length = 0;  for (;;) {    if (last->next == NULL) break;    last = last->next;    length++;  }  // Set element to add to the end of the list  return(length);}// --------------------------------------------// Outline    : Get list elements// Argument   : struct _cell_t *p  List pointer//            : int    pos         The list element position you get  // Return     : When list elements or elements don't exist, return 0// --------------------------------------------float listItem(struct cell_t *p, int pos){  // When element position you get is below 0, return 0  if (pos <= 0) { return (0); }  // When element position you get is larger than the list length, return 0  int l = listLength(p);    // Get list length  if (l < pos) { return (0); }  struct cell_t *target;    // Element about to be deleted  target = p;               // Set first element  // Move to the target element to be retrieved  for (int i = 0;i < pos;i++) {    target = target->next;  // Renew the target element to be got  }  return target->data;}// --------------------------------------------// Outline    : inserting to the list// Argument   : struct _cell_t *p   List pointer//            : int pos             insert position//            : float data          insert data// Return     : Success:0, Error:-1// --------------------------------------------int listInsert(struct cell_t *p, int pos, float data){  // When insert position is below 0 return error (no action)  if (pos <= 0) { return (-1); }  // When insert positon is longer than the list length + 1 return error (no action)  int l = listLength(p);  // Get list length  if (l+1 < pos) { return (-1); }   // When insert position is the end of the list  if (l+1 == pos) {    // Add to the end of the list    listAdd(p, data);    return (0);  }  struct cell_t *item, *target, *before;	// The element to be inserted, of the insert position, and one before the element.  // Get list elements  item = new cell_t;  // When failed to get the list elements return error (no action)  if(item == NULL) { return(-1); }  target = p;  // Move to the target element of insert  for (int i = 0;i < pos;i++) {    before = target;        // Save one before the insert element    target = target->next;  // Renew the insert object  }  // When insert target exists  item->data = data;    // Set element data  item->next = target;  // Set the next element  before->next = item;  // Set the element of the target to the one next the target element  return(0);}// --------------------------------------------// Outline    : Replacement of list elements// Argument   : struct _cell_t *p  List pointer//            : int pos            Replacement position//            : float data         Replacement data// Return     : Success:0, Error:-1// --------------------------------------------int listReplace(struct cell_t *p, int pos, float data){  // When the replacement position is below 0, return error (no action)  if (pos <= 0) { return (-1); }  // When the replacement position is larger than the list, return error (no action)  int l = listLength(p);  // Get list length  if (l < pos) { return (-1); }   struct cell_t *target;  // Replacement element  target = p;  // Move to the target element of replacement  for (int i = 0;i < pos;i++) {    target = target->next;  // Renew the element of the replacement target   }  // When the replacement target element exists  target->data = data;      // Set element data  return(0);}// --------------------------------------------// Outline    : Does the specified data exist in the list elements?// Argument   : struct _cell_t *p  List pointer//            : float data         Search data// Return     : Exists: true, does not exist: false// --------------------------------------------bool listIsContain(struct cell_t *p, float data){  struct cell_t *elm = p;  // Search data in all elements in the list  for (;;) {    // Break after reaching the end of the list    if (elm->next == NULL) break;    // Get the next element in the list    elm = elm->next;    // Return true when data exists in the list    if (elm->data == data) return true;  }  // Return false when data does not exist in the list  return false;}// --------------------------------------------// Outline    : Round off//            : float  arg    Argument// Return     : Calculation result// --------------------------------------------int scratchRound(float arg){  return round(arg);}// --------------------------------------------// Outline    : Arithmetic operation// Argument   : byte   opeID  Operation ID//            : float  arg    Argument// Return     : Calculation result// --------------------------------------------float math(byte opeID, float arg)              // Arithmetic operation{  float result;  switch (opeID) {    case SQRT:      result = sqrt(arg);    break;    case ABS:     // |n|      result = abs(arg);    break;    case SIN:     // sin(n)    {      float rad = arg * PI / 180.0;      result = sin(rad);    }    break;    case COS:     // cos(n)    {      float rad = arg * PI / 180.0;      result = cos(rad);    }    break;    case TAN:     // tan(n)    {      float rad = arg * PI / 180.0;      result = tan(rad);    }    break;/*    case ASIN:    // arcsin(n)    case ACOS:    // arccos(n)    case ATAN:    // arctan(n)    break;*/    case LN:      // loge      result = log(arg);    break;    case LOG:     // log10      result = log10(arg);    break;    case POWE:    // e^      result = exp(arg);    break;    case POW10:   // 10^      result = pow(10, arg);    break;    default:      result = 0;    break;      }  return result;}// --------------------------------------------// Outline    : Retrieve timer value// Return     : Timer value(sec)// --------------------------------------------float getTimer(){  return ((millis() - StartTime) / 1000.0);}// --------------------------------------------// Outline    : Reset timer value// --------------------------------------------void resetTimer(){  StartTime = millis();}